<!DOCTYPE html>
<html>
<head>
  <title>Rectangle with WebGL</title>
</head>
<body onload="init()">
  <canvas id="mycanvas" width="900" height="900"></canvas>

  <script type="text/javascript">
    "use strict";
    var shaderProgram;
    var vertexBuffer, indexBuffer;
    var gl;

    // Khởi tạo toàn bộ chương trình
    function init() {
      initWebGL();             // Khởi tạo WebGL
      initShaderProgram();      // Khởi tạo các shader
      initVariableLocations();  // Khởi tạo vị trí các biến
      initGeometry();           // Khởi tạo hình chữ nhật
      tick();                   // Bắt đầu vẽ
    }

    // Khởi tạo WebGL
    function initWebGL() {
      var canvas = document.getElementById("mycanvas");

      var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
      for (var i = 0; i < names.length; ++i) {
        try {
          gl = canvas.getContext(names[i]);
        } catch (e) { }
        if (gl) break;
      }

      if (!gl) {
        alert("WebGL không được hỗ trợ trên trình duyệt này.");
      }
    }

    // Khởi tạo các shader
    function initShaderProgram() {
      var vShaderCode = `
        attribute vec2 aVertexPosition;
        void main() {
          gl_Position = vec4(aVertexPosition, 0.0, 1.0);
        }
      `;

      var fShaderCode = `
        precision highp float;
        uniform vec4 uColor;
        void main() {
          gl_FragColor = uColor;
        }
      `;

      var vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vertexShader, vShaderCode);
      gl.compileShader(vertexShader);

      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, fShaderCode);
      gl.compileShader(fragmentShader);

      shaderProgram = gl.createProgram();
      gl.attachShader(shaderProgram, vertexShader);
      gl.attachShader(shaderProgram, fragmentShader);
      gl.linkProgram(shaderProgram);

      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        console.log(gl.getShaderInfoLog(vertexShader));
      }

      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        console.log(gl.getShaderInfoLog(fragmentShader));
      }

      if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        console.log(gl.getProgramInfoLog(shaderProgram));
      }

      gl.useProgram(shaderProgram);
    }

    // Khởi tạo vị trí các biến
    function initVariableLocations() {
      shaderProgram.uColor = gl.getUniformLocation(shaderProgram, "uColor");
      shaderProgram.aVertexPosition = gl.getAttribLocation(shaderProgram, "aVertexPosition");
    }

    // Khởi tạo hình học hình chữ nhật
    function initGeometry() {
      var vertices = new Float32Array([
        -0.5,  0.5,   // Đỉnh trên trái
         0.5,  0.5,   // Đỉnh trên phải
         0.5, -0.5,   // Đỉnh dưới phải
        -0.5, -0.5    // Đỉnh dưới trái
      ]);

      vertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

      var indices = new Uint16Array([
        0, 1, 2,   // Tam giác 1
        0, 2, 3    // Tam giác 2
      ]);

      indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
    }

    // Vẽ hình chữ nhật
    function draw() {
      gl.clearColor(0, 0.0, 0, 1);  
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.enableVertexAttribArray(shaderProgram.aVertexPosition);
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.vertexAttribPointer(shaderProgram.aVertexPosition, 2, gl.FLOAT, false, 0, 0);

      gl.uniform4fv(shaderProgram.uColor, [0.0, 0.0, 1.0, 1.0]); // Màu xanh

      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
    }

    // Vòng lặp vẽ
    function tick() {
      requestAnimationFrame(tick);
      draw();
    }
  </script>
</body>
</html>