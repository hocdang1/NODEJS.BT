<!DOCTYPE html>
<html>
<head>
  <title>Triangle</title>
</head>
<body onload="init()">
  <canvas id="mycanvas" width="900" height="900"></canvas>

  <script type="text/javascript" src="rAF.js"></script>
  <script id="vertex" type="x-shader">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexColor;
    varying vec3 vColor;

    void main() {
      gl_Position = vec4(aVertexPosition, 1.0);
      vColor = aVertexColor;  // Pass the color to the fragment shader
    }
  </script>

  <script id="fragment" type="x-shader">
    precision highp float;
    varying vec3 vColor;

    void main() {
      if(gl_FragCoord.x<440.0)
        gl_FragColor = vec4(vColor, 1.0);
      else
      gl_FragColor = vec4(0.0, 0.0,1.0,1.0);
    }
  </script>

  <script id="fragment1" type="x-shader">
    precision highp float;
    varying vec3 vColor;

    void main() {
      gl_FragColor = vec4(vColor, 1.0);  // Use interpolated color
    }
  </script>

  <script type="text/javascript">
    "use strict";
    var shaderProgram;
    var cubeVertexPositionBuffer;
    var gl;

    function init() {
      initWebGL();
      initShaderProgram();
      initVariableLocations();
      initGeometry();
      tick();
    }

    function initWebGL() {
      var canvas = document.getElementById("mycanvas");

      var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
      for (var i = 0; i < names.length; ++i) {
        try {
          gl = canvas.getContext(names[i]);
        }
        catch (e) { }
        if (gl) break;
      }
    }

    function initShaderProgram() {
      var v = document.getElementById("vertex").textContent;
      var f = document.getElementById("fragment").textContent;

      var vs = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vs, v);
      gl.compileShader(vs);

      var fs = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fs, f);
      gl.compileShader(fs);

      shaderProgram = gl.createProgram();
      gl.attachShader(shaderProgram, vs);
      gl.attachShader(shaderProgram, fs);
      gl.linkProgram(shaderProgram);

      if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS))
        console.log(gl.getShaderInfoLog(vs));

      if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS))
        console.log(gl.getShaderInfoLog(fs));

      if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS))
        console.log(gl.getProgramInfoLog(shaderProgram));

      gl.useProgram(shaderProgram);
    }

    function initVariableLocations() {
      shaderProgram.aVertexPosition = gl.getAttribLocation(shaderProgram, "aVertexPosition");
      shaderProgram.aVertexColor = gl.getAttribLocation(shaderProgram, "aVertexColor");
    }

    function initGeometry() {
      var vertices = new Float32Array([
        // Positions       // Colors
        -0.5,  0.5, 0.0,   1.0, 0.0, 0.0,
        -0.5, -0.5, 0.0,   0.0, 1.0, 0.0,
         0.5, -0.5, 0.0,   0.0, 0.0, 1.0
      ]);

      cubeVertexPositionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

      // Position attribute (3 components per vertex)
      gl.vertexAttribPointer(shaderProgram.aVertexPosition, 3, gl.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 0);
      gl.enableVertexAttribArray(shaderProgram.aVertexPosition);

      // Color attribute (3 components per vertex)
      gl.vertexAttribPointer(shaderProgram.aVertexColor, 3, gl.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT);
      gl.enableVertexAttribArray(shaderProgram.aVertexColor);
    }

    function draw() {
      gl.clearColor(0, 0.0, 0, 1);  
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.drawArrays(gl.TRIANGLES, 0, 3);  // Drawing the triangle
    }

    function animate() { }

    function tick() {
      requestAnimationFrame(tick);
      animate();
      draw();
    }
  </script>
</body>
</html>
